from Programs.Source.testutils import test, import_path
from Programs.Source.mantis import Mantis
from Programs.Source.twine import Twine
from circuit import Circuit

skinny = import_path('skinny', 'Programs/Source/skinny.mpc')
skinny_proj = import_path('skinny', 'Programs/Source/skinny_n_proj.mpc')
aes = import_path('aes', 'Programs/Source/aes_proj.mpc')
import sys

idx = 1
while sys.argv[idx] != 'garbling_benchmark':
    idx += 1

circuit = sys.argv[idx+1]
simd = int(sys.argv[idx+2])

print(circuit)

skinny_circuits = {
    'skinny64_64': (1, 4, skinny.skinny_64_64_N),
    'skinny64_128': (2,4, lambda b,k: skinny.skinny_64_128_N(b, k[:16], k[16:])),
    'skinny64_192': (3,4, lambda b,k: skinny.skinny_64_192_N(b, k[:16], k[16:32], k[32:])),
    'skinny128_128': (1,8, skinny.skinny_128_128_N),
    'skinny128_256': (2,8, lambda b,k: skinny.skinny_128_256_N(b, k[:16], k[16:])),
    'skinny128_384': (3,8, lambda b,k: skinny.skinny_128_384_N(b, k[:16], k[16:32], k[32:])),
    'skinny64_64_proj': (1, 4, skinny_proj.skinny_64_64_n),
    'skinny64_128_proj': (2,4, lambda b,k: skinny_proj.skinny_64_128_n(b, k[:16], k[16:])),
    'skinny64_192_proj': (3,4, lambda b,k: skinny_proj.skinny_64_192_n(b, k[:16], k[16:32], k[32:])),
    'skinny128_128_proj': (1,8, skinny_proj.skinny_128_128_n),
    'skinny128_256_proj': (2,8, lambda b,k: skinny_proj.skinny_128_256_n(b, k[:16], k[16:])),
    'skinny128_384_proj': (3,8, lambda b,k: skinny_proj.skinny_128_384_n(b, k[:16], k[16:32], k[32:]))
}

if circuit in skinny_circuits.keys():
    keysize, cellsize, enc = skinny_circuits[circuit]
    key = [[sbit(0) for i in range(cellsize)] for j in range(keysize * 16)]
    blocks = [[[sbit(0) for j in range(cellsize)] for k in range(16)] for i in range(simd)]
    if circuit.endswith('_proj'):
        blocks = [skinny_proj.compose_block(block) for block in blocks]
    start_timer(1)
    out_blocks = enc(blocks, key)
    stop_timer(1)
    for out in out_blocks:
        for cell in out:
            for bit in cell:
                bit.reveal()

if circuit == 'mantis7' or circuit== 'mantis7_proj':
    sb1 = sbits.get_type(1)
    sb = sbits.get_type(simd)
    cb = cbits.get_type(simd)

    start_timer(1)
    key = [sb(0) for _ in range(128)]
    message = [sb(0) for _ in range(64)]
    tweak = [sb(0) for _ in range(64)]

    mantis = Mantis(rounds = 7, variant='bit' if circuit == 'mantis7' else 'proj')
    ciphertext = mantis.encrypt(message, key, tweak)
    stop_timer(1)
    for b in ciphertext:
        b.reveal()

if circuit in ['twine80', 'twine80_proj', 'twine128', 'twine128_proj']:
    sb = sbits.get_type(simd)
    keysize = 80 if circuit == 'twine80' or circuit == 'twine80_proj' else 128
    start_timer(1)
    key = [sb(0) for _ in range(keysize)]
    message = [sb(2**simd-1) for _ in range(64)]

    twine = Twine(keysize, variant='proj' if circuit.endswith('_proj') else 'bit')
    ciphertext = twine.encrypt(message, key)
    stop_timer(1)
    for b in ciphertext:
        b.reveal()

if circuit == 'aes128':
    sb128 = sbits.get_type(128)
    key = sb128(0x2b7e151628aed2a6abf7158809cf4f3c)
    plaintext = sb128(0x6bc1bee22e409f96e93d7e117393172a)
    aes128 = Circuit('aes_128')
    start_timer(1)
    ciphertexts = aes128(sbitvec([key] * simd), sbitvec([plaintext] * simd)).elements()
    stop_timer(1)
    for ciphertext in ciphertexts:
        ciphertext.reveal()

if circuit == 'aes128_proj':
    key = [[sbit(0) for i in range(8)] for j in range(16)]
    blocks = [aes.compose_block([[sbit(0) for j in range(8)] for k in range(16)]) for _ in range(simd)]
    start_timer(1)
    expanded_key = aes.expand_key(aes.compose_block(key))
    ciphertexts = [aes.aes_128(block, expanded_key) for block in blocks]
    stop_timer(1)
    for block in blocks:
        for cell in block:
            cell.reveal()